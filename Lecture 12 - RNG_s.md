# Lecture 12 - Pseudo-Random Number Generation

## Introduction

Randomness plays a crucial role in cryptography, providing the unpredictability and uniqueness necessary for secure communication. In this lecture, we will dive into the world of random and pseudo-random numbers, exploring their generation methods and applications in cryptography. We will also examine stream ciphers, which leverage the properties of pseudo-random number generators to encrypt data. By the end of this session, you will have a solid understanding of pseudo-random number generation algorithms and their significance in modern cryptography.

## Learning Objectives

1. Understand the difference between true random numbers and pseudo-random numbers.
2. Explore the concepts of random bit streams, pseudo-random bit streams, and pseudo-random functions (PRFs).
3. Learn about the use of random and pseudo-random numbers in cryptography, including initialization vectors, seeds, and keys.
4. Gain familiarity with the RAND() function in OpenSSL for generating random numbers.
5. Study purpose-built pseudo-random number generation algorithms, such as the Linear Congruential Generator (LCG) and Blum Blum Shub (BBS).
6. Understand the properties that make symmetric block ciphers suitable for building pseudo-random number generators.
7. Explore block cipher modes of operation for pseudo-random number generation, including CTR and OFB modes.
8. Learn about the ANSI X9.17 pseudo-random number generator and its strength factors.

## Random Numbers and Pseudo-Random Numbers

### True Random Numbers (TRNG)

True random numbers are generated from unpredictable physical processes, such as atmospheric noise, radioactive decay, or mouse movements. These sources provide genuine randomness that cannot be replicated or predicted. However, generating true random numbers can be slow and resource-intensive, making them impractical for many cryptographic applications.

### Pseudo-Random Numbers (PRNG)

Pseudo-random numbers, on the other hand, are generated using deterministic algorithms that produce sequences of numbers that appear random. While not truly random, these sequences exhibit statistical properties similar to random numbers. PRNGs are efficient, reproducible, and widely used in cryptography.

#### Random Bit Streams and Pseudo-Random Bit Streams

- Random Bit Streams: A sequence of bits generated from a true random source, exhibiting no discernible pattern or predictability.
- Pseudo-Random Bit Streams: A sequence of bits generated by a deterministic algorithm, designed to mimic the properties of a random bit stream.

#### Pseudo-Random Functions (PRFs)

A pseudo-random function (PRF) is a function that takes a seed value and produces an output that is computationally indistinguishable from a truly random function. PRFs are essential building blocks in cryptography, used for generating keys, initialization vectors, and other randomized values.

## Use of Random and Pseudo-Random Numbers in Cryptography

Random and pseudo-random numbers find extensive use in cryptography:

- **Initialization Vectors (IVs)**: IVs are used to randomize the encryption process, ensuring that identical plaintext blocks encrypt to different ciphertext blocks. They prevent certain types of attacks, such as known-plaintext attacks.

- **Seeds**: Seeds are initial values used to kickstart a pseudo-random number generator. They provide the starting point for generating a sequence of pseudo-random numbers.

- **Keys**: Cryptographic keys are often generated using random or pseudo-random number generators to ensure their unpredictability and uniqueness.

## OpenSSL and the RAND() Function

OpenSSL, a widely used cryptographic library, provides the RAND() function for generating random numbers. The RAND() function combines various sources of randomness, such as system events and user input, to produce high-quality random numbers suitable for cryptographic purposes.

```c
#include <openssl/rand.h>

unsigned char buffer[16];
RAND_bytes(buffer, sizeof(buffer));
```

## Pseudo-Random Number Generation Algorithms

### Purpose-Built Algorithms

#### Linear Congruential Generator (LCG)

The Linear Congruential Generator (LCG) is a simple and widely used pseudo-random number generation algorithm. It generates a sequence of numbers based on a recursive linear equation:

```
X(n+1) = (a * X(n) + c) mod m
```

Where:
- X(n) is the current number in the sequence
- X(n+1) is the next number in the sequence
- a, c, and m are constants

Example:
Let's generate a sequence of pseudo-random numbers using LCG with the following parameters:
- a = 5
- c = 3
- m = 16
- X(0) = 7 (seed value)

Step 1: X(1) = (5 * 7 + 3) mod 16 = 6
Step 2: X(2) = (5 * 6 + 3) mod 16 = 1
Step 3: X(3) = (5 * 1 + 3) mod 16 = 8
Step 4: X(4) = (5 * 8 + 3) mod 16 = 11
...

The generated sequence would be: 7, 6, 1, 8, 11, ...

#### Tests for a Strong Random Number Generator

A strong random number generator should possess the following properties:

1. **Uniformity**: The generated numbers should be uniformly distributed across the possible range of values.
2. **Independence**: The generated numbers should be statistically independent of each other, with no discernible patterns or correlations.
3. **Unpredictability**: Given a subsequence of generated numbers, it should be computationally infeasible to predict the next number in the sequence.

#### Blum Blum Shub (BBS)

The Blum Blum Shub (BBS) algorithm is a cryptographically secure pseudo-random number generator based on the hardness of the quadratic residuosity problem. It generates a sequence of numbers using the following formula:

```
X(n+1) = X(n)^2 mod M
```

Where:
- X(n) is the current number in the sequence
- X(n+1) is the next number in the sequence
- M is the product of two large prime numbers p and q, such that p ≡ q ≡ 3 (mod 4)

Example:
Let's generate a sequence of pseudo-random numbers using BBS with the following parameters:
- p = 7 (prime)
- q = 11 (prime)
- M = p * q = 77
- X(0) = 3 (seed value)

Step 1: X(1) = 3^2 mod 77 = 9
Step 2: X(2) = 9^2 mod 77 = 4
Step 3: X(3) = 4^2 mod 77 = 16
Step 4: X(4) = 16^2 mod 77 = 25
...

The generated sequence would be: 3, 9, 4, 16, 25, ...

### Cipher-Based Algorithms

Symmetric block ciphers, such as AES and DES, possess properties that make them suitable candidates for building pseudo-random number generators:

- **Confusion**: The output of the cipher should be statistically unrelated to the input, making it difficult to deduce the input from the output.
- **Diffusion**: A small change in the input should result in a significant change in the output, spreading the effect of the input across the entire output.
- **Avalanche Effect**: Flipping a single bit in the input should result in approximately half of the output bits being flipped, making the output appear random.

#### Block Cipher Modes of Operation for PRNG

Block cipher modes of operation, such as CTR (Counter) and OFB (Output Feedback), can be used to generate pseudo-random bit streams. These modes leverage the block cipher's properties to produce randomized output.

##### CTR Mode

In CTR mode, a counter is encrypted using the block cipher, and the resulting ciphertext is used as the pseudo-random output. The counter is incremented for each block, ensuring that each output block is unique.

```
Pseudo-Random Output = Encrypt(Key, Counter)
```

The seed components in CTR mode include the key and the initial counter value.

##### OFB Mode

In OFB mode, the output of the block cipher is fed back as the input for the next encryption operation. The resulting ciphertext is used as the pseudo-random output.

```
Pseudo-Random Output = Encrypt(Key, Previous Output)
```

The seed components in OFB mode include the key and the initialization vector (IV).

### ANSI X9.17 PRNG

The ANSI X9.17 pseudo-random number generator is a standardized algorithm that combines a block cipher (usually Triple DES) with a timestamp and a secret key to generate pseudo-random numbers.

#### Input, Keys, and Output

- **Input**: The ANSI X9.17 PRNG takes a seed value and a timestamp as input.
- **Keys**: It uses two secret keys, K1 and K2, which are used for encryption and decryption operations.
- **Output**: The PRNG generates a sequence of pseudo-random numbers based on the input and keys.

#### Factors Contributing to Strength

The strength of the ANSI X9.17 PRNG is attributed to several factors:

1. **Use of a Secure Block Cipher**: The algorithm relies on a secure block cipher, such as Triple DES, which provides strong encryption and ensures the pseudo-random properties of the output.
2. **Incorporation of a Timestamp**: The inclusion of a timestamp adds an element of unpredictability to the generated numbers, making them harder to predict or reproduce.
3. **Secret Keys**: The use of secret keys, K1 and K2, prevents unauthorized parties from replicating the pseudo-random sequence.
4. **Iteration**: The PRNG iterates the process multiple times, further enhancing the randomness and security 


## Cased Study

In this case study we implement secure data encryption for wireless sensor networks (WSNs). 

In wireless sensor networks, we often have multiple sensor nodes collecting sensitive environmental data that needs to be transmitted securely. The key challenges we're addressing are:

1. Resource Constraints: Sensor nodes typically have limited processing power, memory, and energy resources
2. Security Requirements: We need to protect the confidentiality of sensor readings during transmission
3. Efficiency: The encryption method must be lightweight yet secure
4. Randomness: We need unpredictable encryption to prevent pattern analysis

The PRNG (Pseudo-Random Number Generator) implementation in Counter (CTR) mode is particularly suitable because:

- It allows parallel processing of blocks
- Generates random keystreams without needing to store the entire sequence
- Provides good security with relatively low computational overhead
- Enables unique encryption patterns for each transmission

The key components of this implementation are:

1. The FiestelCipher Class:
   - Implements a balanced Feistel network with configurable rounds
   - Uses a simple round function combining XOR and bit rotation
   - Includes both encryption and decryption capabilities
   - Operates on 64-bit blocks for efficiency on resource-constrained devices

2. The PRNG Class:
   - Implements a Linear Congruential Generator (LCG) for pseudo-random number generation
   - Uses carefully chosen parameters to ensure a good period and distribution
   - Maintains internal state for continuous random number generation

3. The SensorNode Class:
   - Simulates a sensor node with encryption capabilities
   - Implements CTR mode encryption using the PRNG
   - Handles data padding and block operations
   - Maintains a counter and nonce (number used once) for unique keystream generation

The implementation follows these security principles:

1. Counter Mode (CTR) Benefits:
   - No need for padding in the final implementation
   - Parallelizable encryption/decryption
   - No error propagation
   - Acts as a stream cipher

2. PRNG Usage Motivation:
   - Provides deterministic but seemingly random keystream
   - Allows reconstruction of the keystream for decryption
   - More efficient than storing pre-generated random numbers
   - Suitable for resource-constrained environments

3. Security Features:
   - Unique nonce (number used once) for each encryption session
   - Counter ensures unique keystream blocks
   - Feistel network provides confusion and diffusion
   - Modular design allows easy algorithm updates

To use this implementation in a real WSN:

1. Each sensor node would be initialized with:
   - A unique node ID
   - A pre-shared encryption key
   - The Feistel cipher implementation
   - The PRNG implementation

2. For each sensor reading:
   - Generate a new nonce (number used once)
   - Encrypt the data using CTR mode
   - Transmit the encrypted data along with the nonce (number used once)

3. The receiving station would:
   - Receive the encrypted data and nonce (number used once)
   - Use the same key and algorithms to decrypt
   - Verify the data integrity

By leveraging pseudo-random number generation and stream ciphers, we can achieve secure and efficient data encryption in wireless sensor networks.

Here is the Python code for the implementation:

```python
import struct
from typing import List, Tuple
import time
import secrets

class FiestelCipher:
    """
    Implementation of a Feistel Network block cipher for sensor data encryption.
    Uses a simple round function for demonstration purposes.
    """
    def __init__(self, num_rounds: int = 8):
        self.num_rounds = num_rounds
        self.block_size = 64  # 64-bit blocks
        
    def _round_function(self, right_half: int, round_key: int) -> int:
        """
        Simple round function combining XOR and bit rotation
        For production use, this should be replaced with a stronger function
        """
        # Combine right half with round key using XOR
        mixed = right_half ^ round_key
        # Rotate bits left by 3 positions
        rotated = ((mixed << 3) | (mixed >> 29)) & 0xFFFFFFFF
        return rotated
    
    def _generate_round_keys(self, key: int) -> List[int]:
        """Generate round keys from the main key"""
        round_keys = []
        current_key = key
        for _ in range(self.num_rounds):
            # Generate different key for each round using simple key schedule
            current_key = ((current_key * 1103515245 + 12345) & 0xFFFFFFFF)
            round_keys.append(current_key)
        return round_keys
    
    def encrypt_block(self, plaintext_block: int, key: int) -> int:
        """
        Encrypt a 64-bit block using Feistel network
        """
        # Split block into left and right halves (32 bits each)
        left = (plaintext_block >> 32) & 0xFFFFFFFF
        right = plaintext_block & 0xFFFFFFFF
        
        # Generate round keys
        round_keys = self._generate_round_keys(key)
        
        # Feistel rounds
        for i in range(self.num_rounds):
            # Apply round function and XOR with left half
            new_right = left ^ self._round_function(right, round_keys[i])
            # Swap halves
            left = right
            right = new_right
            
        # Final swap and combine halves
        return ((right << 32) | left) & ((1 << 64) - 1)
    
    def decrypt_block(self, ciphertext_block: int, key: int) -> int:
        """
        Decrypt a 64-bit block using Feistel network
        Uses the same structure as encryption but with reversed round keys
        """
        # Split block into left and right halves
        left = (ciphertext_block >> 32) & 0xFFFFFFFF
        right = ciphertext_block & 0xFFFFFFFF
        
        # Generate and reverse round keys
        round_keys = self._generate_round_keys(key)
        round_keys.reverse()
        
        # Feistel rounds
        for i in range(self.num_rounds):
            new_right = left ^ self._round_function(right, round_keys[i])
            left = right
            right = new_right
            
        return ((right << 32) | left) & ((1 << 64) - 1)

class PRNG:
    """
    Implements a simple PRNG for CTR mode encryption
    """
    def __init__(self, seed: int):
        self.state = seed
        
    def next(self) -> int:
        """Generate next pseudo-random number"""
        # Linear Congruential Generator parameters
        a = 1664525
        c = 1013904223
        m = 2**32
        
        self.state = (a * self.state + c) % m
        return self.state

class SensorNode:
    """
    Simulates a sensor node with encryption capabilities
    """
    def __init__(self, node_id: int, encryption_key: int):
        self.node_id = node_id
        self.cipher = FiestelCipher()
        self.encryption_key = encryption_key
        # Initialize CTR mode with random nonce
        self.nonce = secrets.randbits(32)
        self.counter = 0
        
    def _pad_data(self, data: bytes) -> List[int]:
        """Pad data to block size and split into blocks"""
        # Pad with PKCS7
        pad_length = 8 - (len(data) % 8)
        padded_data = data + bytes([pad_length] * pad_length)
        
        # Split into 64-bit blocks
        blocks = []
        for i in range(0, len(padded_data), 8):
            block = int.from_bytes(padded_data[i:i+8], 'big')
            blocks.append(block)
        return blocks
    
    def encrypt_sensor_data(self, plaintext: str) -> Tuple[bytes, int]:
        """
        Encrypt sensor data using CTR mode with PRNG
        Returns ciphertext and nonce
        """
        # Convert plaintext to bytes and pad
        data = plaintext.encode('utf-8')
        blocks = self._pad_data(data)
        
        # Initialize PRNG with nonce for this message
        prng = PRNG(self.nonce)
        ciphertext_blocks = []
        
        # Encrypt each block in CTR mode
        for block in blocks:
            # Generate keystream block
            counter_block = (self.nonce << 32) | self.counter
            keystream_block = self.cipher.encrypt_block(counter_block, self.encryption_key)
            
            # XOR plaintext with keystream
            ciphertext_block = block ^ keystream_block
            ciphertext_blocks.append(ciphertext_block)
            
            self.counter = (self.counter + 1) & 0xFFFFFFFF
        
        # Combine blocks into final ciphertext
        ciphertext = b''
        for block in ciphertext_blocks:
            ciphertext += block.to_bytes(8, 'big')
            
        return ciphertext, self.nonce

def main():
    # Example usage
    ENCRYPTION_KEY = 0x1234567890ABCDEF
    sensor = SensorNode(1, ENCRYPTION_KEY)
    
    # Sample sensor reading
    plaintext_data = "Sensor readings: Temperature: 25.3°C, Humidity: 60%"
    
    # Encrypt the data
    ciphertext, nonce = sensor.encrypt_sensor_data(plaintext_data)
    
    print(f"Original data: {plaintext_data}")
    print(f"Encrypted data (hex): {ciphertext.hex()}")
    print(f"Nonce: {hex(nonce)}")


if __name__ == "__main__":
    main()
```

Output:

```
Original data: Sensor readings: Temperature: 25.3°C, Humidity: 60%
Encrypted data (hex): f7523762fe1e889bc0522d79ff2bdbd3866b1c7ee149da88d34e1b77ab2c9adc8e14dba5d2c088a1d44e6070f8b8d1d38219093295a8aced
Nonce: 0xe4089768
```

## The Importance of the Nonce (Number Used Once)

The nonce plays a crucial role in ensuring the security of the CTR mode. Here's why:

### Uniqueness 

The nonce must be unique for each message encrypted under the same key. If the same nonce is reused with the same key, it can completely break the security of the system. An attacker who observes two ciphertexts generated with the same nonce and key can XOR the ciphertexts together to eliminate the keystream, leaving only the XOR of the two plaintexts. This can reveal information about the plaintexts.

### Unpredictability

While the nonce doesn't necessarily need to be random, it should be unpredictable to an adversary. If an adversary can predict the nonce, they might be able to precompute the keystream and break the encryption.

### Preventing replay attacks

Using a unique nonce for each message prevents replay attacks. If an attacker tries to replay an intercepted ciphertext, the receiver will detect that the nonce has been reused and reject the message.

Common ways to generate nonces include using a counter that increments for each message, using a random number generator, or deriving the nonce from a timestamp. The method of nonce generation should ensure uniqueness and unpredictability.

## Conclusion

Pseudo-random number generation plays a vital role in modern cryptography, enabling secure communication and data protection. By understanding the concepts of true randomness, pseudo-randomness, and the algorithms used to generate pseudo-random numbers, you can appreciate the importance of randomness in cryptographic systems. Purpose-built algorithms like LCG and BBS, along with cipher-based techniques using block cipher modes, provide efficient and secure means of generating pseudo-random numbers. The ANSI X9.17 PRNG serves as a standardized approach, combining the strengths of block ciphers with timestamps and secret keys.

As you continue your journey in cryptography, remember the significance of pseudo-random number generation in ensuring the confidentiality, integrity, and authenticity of information. 

## References

1. Menezes, A. J., Van Oorschot, P. C., & Vanstone, S. A. (2018). Handbook of applied cryptography. CRC press.
2. Schneier, B. (1996). Applied cryptography: Protocols, algorithms, and source code in C. John Wiley & Sons.
3. National Institute of Standards and Technology (NIST). (2015). NIST Special Publication 800-90A Revision 1: Recommendation for Random Number Generation Using Deterministic Random Bit Generators.
4. Knuth, D. E. (1997). The art of computer programming, volume 2: Seminumerical algorithms. Addison-Wesley.